"use strict";
/**
 * @module Errors
 *
 * @description Exports error classes which may be returned by this client
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.IdpcServerError = exports.IdpcUmprnNotFoundError = exports.IdpcUdprnNotFoundError = exports.IdpcKeyNotFoundError = exports.IdpcPostcodeNotFoundError = exports.IdpcResourceNotFoundError = exports.IdpcLimitReachedError = exports.IdpcBalanceDepletedError = exports.IdpcRequestFailedError = exports.IdpcInvalidKeyError = exports.IdpcUnauthorisedError = exports.IdpcBadRequestError = exports.IdpcApiError = exports.IdealPostcodesError = void 0;
// Take note of https://github.com/Microsoft/TypeScript/issues/13965
/**
 * IdealPostcodesError
 *
 * Base error class for all API responses that return an error. This class
 * is used where a JSON body is not provided or invalid
 * E.g. 503 rate limit response, JSON parse failure response
 */
var IdealPostcodesError = /** @class */ (function (_super) {
    __extends(IdealPostcodesError, _super);
    /**
     * Instantiate IdealPostcodesError
     */
    function IdealPostcodesError(options) {
        var _newTarget = this.constructor;
        var _this = this;
        var trueProto = _newTarget.prototype;
        _this = _super.call(this) || this;
        _this.__proto__ = trueProto;
        var message = options.message, httpStatus = options.httpStatus, _a = options.metadata, metadata = _a === void 0 ? {} : _a;
        _this.message = message;
        _this.name = "Ideal Postcodes Error";
        _this.httpStatus = httpStatus;
        _this.metadata = metadata;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, IdealPostcodesError);
        }
        return _this;
    }
    return IdealPostcodesError;
}(Error));
exports.IdealPostcodesError = IdealPostcodesError;
/**
 * IdpcApiError
 *
 * Base error class for API responses with a JSON body. Typically a subclass
 * will be used to capture the error category (e.g. 400, 401, 500, etc)
 */
var IdpcApiError = /** @class */ (function (_super) {
    __extends(IdpcApiError, _super);
    /**
     * Returns an API error instance
     */
    function IdpcApiError(httpResponse) {
        var _this = _super.call(this, {
            httpStatus: httpResponse.httpStatus,
            message: httpResponse.body.message,
        }) || this;
        _this.response = httpResponse;
        return _this;
    }
    return IdpcApiError;
}(IdealPostcodesError));
exports.IdpcApiError = IdpcApiError;
/**
 * IdpcBadRequestError
 *
 * Captures API responses that return a 400 (Bad Request Error) response
 *
 * Examples include:
 * - Invalid syntax submitted
 * - Invalid date range submitted
 * - Invalid tag submitted
 */
var IdpcBadRequestError = /** @class */ (function (_super) {
    __extends(IdpcBadRequestError, _super);
    function IdpcBadRequestError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcBadRequestError;
}(IdpcApiError));
exports.IdpcBadRequestError = IdpcBadRequestError;
/**
 * IdpcUnauthorisedError
 *
 * Captures API responses that return a 401 (Unauthorised) response
 *
 * Examples include:
 * - Invalid api_key
 * - Invalid user_token
 * - Invalid licensee
 */
var IdpcUnauthorisedError = /** @class */ (function (_super) {
    __extends(IdpcUnauthorisedError, _super);
    function IdpcUnauthorisedError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcUnauthorisedError;
}(IdpcApiError));
exports.IdpcUnauthorisedError = IdpcUnauthorisedError;
/**
 * IpdcInvalidKeyError
 *
 * Invalid API Key presented for request
 */
var IdpcInvalidKeyError = /** @class */ (function (_super) {
    __extends(IdpcInvalidKeyError, _super);
    function IdpcInvalidKeyError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcInvalidKeyError;
}(IdpcUnauthorisedError));
exports.IdpcInvalidKeyError = IdpcInvalidKeyError;
/**
 * IdpcRequestFailedError
 *
 * Captures API responses that return a 402 (Request Failed) response
 *
 * Examples include:
 * - Key balance depleted
 * - Daily key limit reached
 */
var IdpcRequestFailedError = /** @class */ (function (_super) {
    __extends(IdpcRequestFailedError, _super);
    function IdpcRequestFailedError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcRequestFailedError;
}(IdpcApiError));
exports.IdpcRequestFailedError = IdpcRequestFailedError;
/**
 * IdpcBalanceDepleted
 *
 * Balance on key has been depleted
 */
var IdpcBalanceDepletedError = /** @class */ (function (_super) {
    __extends(IdpcBalanceDepletedError, _super);
    function IdpcBalanceDepletedError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcBalanceDepletedError;
}(IdpcRequestFailedError));
exports.IdpcBalanceDepletedError = IdpcBalanceDepletedError;
/**
 * IdpcLimitReachedError
 *
 * Limit reached. One of your lookup limits has been breached for today. This
 * could either be your total daily limit on your key or the individual IP
 * limit. You can either wait for for the limit to reset (after a day) or
 * manually disable or increase your limit.
 */
var IdpcLimitReachedError = /** @class */ (function (_super) {
    __extends(IdpcLimitReachedError, _super);
    function IdpcLimitReachedError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcLimitReachedError;
}(IdpcRequestFailedError));
exports.IdpcLimitReachedError = IdpcLimitReachedError;
/**
 * IdpcResourceNotFoundError
 *
 * Captures API responses that return a 404 (Resource Not Found) response
 *
 * Examples include:
 * - Postcode not found
 * - UDPRN not found
 * - Key not found
 */
var IdpcResourceNotFoundError = /** @class */ (function (_super) {
    __extends(IdpcResourceNotFoundError, _super);
    function IdpcResourceNotFoundError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcResourceNotFoundError;
}(IdpcApiError));
exports.IdpcResourceNotFoundError = IdpcResourceNotFoundError;
/**
 * IdpcPostcodeNotFoundError
 *
 * Requested postcode does not exist
 */
var IdpcPostcodeNotFoundError = /** @class */ (function (_super) {
    __extends(IdpcPostcodeNotFoundError, _super);
    function IdpcPostcodeNotFoundError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcPostcodeNotFoundError;
}(IdpcResourceNotFoundError));
exports.IdpcPostcodeNotFoundError = IdpcPostcodeNotFoundError;
/**
 * IdpcKeyNotFoundError
 *
 * Requested API Key does not exist
 */
var IdpcKeyNotFoundError = /** @class */ (function (_super) {
    __extends(IdpcKeyNotFoundError, _super);
    function IdpcKeyNotFoundError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcKeyNotFoundError;
}(IdpcResourceNotFoundError));
exports.IdpcKeyNotFoundError = IdpcKeyNotFoundError;
/**
 * IdpcUdprnNotFoundError
 *
 * Requested UDPRN does not exist
 */
var IdpcUdprnNotFoundError = /** @class */ (function (_super) {
    __extends(IdpcUdprnNotFoundError, _super);
    function IdpcUdprnNotFoundError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcUdprnNotFoundError;
}(IdpcResourceNotFoundError));
exports.IdpcUdprnNotFoundError = IdpcUdprnNotFoundError;
/**
 * IdpcUmprnNotFoundError
 *
 * Requested UMPRN does not exist
 */
var IdpcUmprnNotFoundError = /** @class */ (function (_super) {
    __extends(IdpcUmprnNotFoundError, _super);
    function IdpcUmprnNotFoundError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcUmprnNotFoundError;
}(IdpcResourceNotFoundError));
exports.IdpcUmprnNotFoundError = IdpcUmprnNotFoundError;
/**
 * IdpcServerError
 *
 * Captures API responses that return a 500 (Server Error) response
 */
var IdpcServerError = /** @class */ (function (_super) {
    __extends(IdpcServerError, _super);
    function IdpcServerError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IdpcServerError;
}(IdpcApiError));
exports.IdpcServerError = IdpcServerError;
// 200 Responses
var OK = 200;
// 300 Responses
var REDIRECT = 300;
// 400 Responses
var BAD_REQUEST = 400;
// 401 Responses
var UNAUTHORISED = 401;
var INVALID_KEY = 4010;
// 402 Responses
var PAYMENT_REQUIRED = 402;
var BALANCE_DEPLETED = 4020;
var LIMIT_REACHED = 4021;
// 404 Responses
var NOT_FOUND = 404;
var POSTCODE_NOT_FOUND = 4040;
var KEY_NOT_FOUND = 4042;
var UDPRN_NOT_FOUND = 4044;
var UMPRN_NOT_FOUND = 4046;
// 500 Responses
var SERVER_ERROR = 500;
var isSuccess = function (code) {
    if (code < OK)
        return false;
    if (code >= REDIRECT)
        return false;
    return true;
};
var isObject = function (o) {
    if (o === null)
        return false;
    if (typeof o !== "object")
        return false;
    return true;
};
var isErrorResponse = function (body) {
    if (!isObject(body))
        return false;
    if (typeof body.message !== "string")
        return false;
    if (typeof body.code !== "number")
        return false;
    return true;
};
/**
 * parse
 *
 * Parses API responses and returns an error for non 2xx responses
 *
 * Upon detecting an error an instance of IdealPostcodesError is returned
 */
var parse = function (response) {
    var httpStatus = response.httpStatus, body = response.body;
    if (isSuccess(httpStatus))
        return;
    if (isErrorResponse(body)) {
        // Test for specific API errors of interest
        var code = body.code;
        if (code === INVALID_KEY)
            return new IdpcInvalidKeyError(response);
        if (code === POSTCODE_NOT_FOUND)
            return new IdpcPostcodeNotFoundError(response);
        if (code === KEY_NOT_FOUND)
            return new IdpcKeyNotFoundError(response);
        if (code === UDPRN_NOT_FOUND)
            return new IdpcUdprnNotFoundError(response);
        if (code === UMPRN_NOT_FOUND)
            return new IdpcUmprnNotFoundError(response);
        if (code === BALANCE_DEPLETED)
            return new IdpcBalanceDepletedError(response);
        if (code === LIMIT_REACHED)
            return new IdpcLimitReachedError(response);
        // If no API errors of interest detected, fall back to http status code
        if (httpStatus === NOT_FOUND)
            return new IdpcResourceNotFoundError(response);
        if (httpStatus === BAD_REQUEST)
            return new IdpcBadRequestError(response);
        if (httpStatus === PAYMENT_REQUIRED)
            return new IdpcRequestFailedError(response);
        if (httpStatus === UNAUTHORISED)
            return new IdpcUnauthorisedError(response);
        if (httpStatus === SERVER_ERROR)
            return new IdpcServerError(response);
    }
    // Generate generic error (backstop)
    return new IdealPostcodesError({ httpStatus: httpStatus, message: JSON.stringify(body) });
};
exports.parse = parse;
