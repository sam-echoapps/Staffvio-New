/**
 * @module Utils
 */
/**
 * toQuery
 *
 * Shallow copies object while omitting undefined attributes
 */
export const toStringMap = (optional) => {
    if (optional === undefined)
        return {};
    return Object.keys(optional).reduce((result, key) => {
        const value = optional[key];
        const reduce = reduceStringMap(value);
        if (reduce.length > 0)
            result[key] = reduce;
        return result;
    }, {});
};
const isString = (i) => typeof i === "string";
const isArray = (i) => Array.isArray(i);
const reduceStringMap = (value) => {
    const result = [];
    if (isArray(value)) {
        value.forEach((val) => {
            if (isNumber(val))
                result.push(val.toString());
            if (isString(val))
                result.push(val);
        });
        return result.join(",");
    }
    if (isNumber(value))
        return value.toString();
    if (isString(value))
        return value;
    return "";
};
const isNumber = (n) => typeof n === "number";
/**
 * toTimeout
 *
 * Returns timeout value from request object. Delegates to default client
 * timeout if not specified
 */
export const toTimeout = ({ timeout }, client) => {
    if (isNumber(timeout))
        return timeout;
    return client.config.timeout;
};
/**
 * toHeader
 *
 * Extracts HTTP Header object from request and client default headers
 *
 * Precendence is given to request specific headers
 */
export const toHeader = ({ header = {} }, client) => {
    return { ...client.config.header, ...toStringMap(header) };
};
/**
 * toAuthHeader
 *
 * Extracts credentials into authorization header format
 */
export const toAuthHeader = (client, options) => {
    const credentials = [];
    const api_key = options.api_key || client.config.api_key;
    credentials.push(["api_key", api_key]);
    const licensee = options.licensee;
    if (licensee !== undefined)
        credentials.push(["licensee", licensee]);
    const user_token = options.user_token;
    if (user_token !== undefined)
        credentials.push(["user_token", user_token]);
    return `IDEALPOSTCODES ${toCredentialString(credentials)}`;
};
/**
 * appendAuthorization
 *
 * Mutates a headers object to include Authorization header. Will insert if found:
 * - api_key
 * - licensee
 * - user_token
 */
export const appendAuthorization = ({ header, options, client, }) => {
    header.Authorization = toAuthHeader(client, options);
    return header;
};
const toCredentialString = (credentials) => {
    return credentials.map(([key, value]) => `${key}="${value}"`).join(" ");
};
// Adds source IP to headers
export const appendIp = ({ header, options }) => {
    const { sourceIp } = options;
    if (sourceIp !== undefined)
        header["IDPC-Source-IP"] = sourceIp;
    return header;
};
// Adds filters to query
export const appendFilter = ({ query, options, }) => {
    const { filter } = options;
    if (filter !== undefined)
        query.filter = filter.join(",");
    return query;
};
// Adds tags to query
export const appendTags = ({ client, query, options, }) => {
    let tags;
    if (client.config.tags.length)
        tags = client.config.tags;
    if (options.tags)
        tags = options.tags;
    if (tags !== undefined)
        query.tags = tags.join(",");
    return query;
};
// Adds pagination attributes to query
export const appendPage = ({ query, options, }) => {
    const { page, limit } = options;
    if (page !== undefined)
        query.page = page.toString();
    if (limit !== undefined)
        query.limit = limit.toString();
    return query;
};
